<!DOCTYPE html>
<html>
<head>
  <title></title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/default.css">
  <link type="text/css" rel="stylesheet" href="../stylesheets/blog-stylesheet.css" />
  <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js">
  </script>
</head>
<body>
<div class = "overlay">
<div class="blog-post-background">
<main>
  <h1>Blocks, Procs, and Lambdas</h1>
  <h2>A Brief Primer on Ruby's Callable Objects</h2>
  <h4>29 January 2015</h4>

  <section>
    <h3>Callable Objects</h3>
    <p>
      In Ruby, a "callable" object is an object which responds to the message (method) <span class = "rbcode">call</span>, and returns some block of code associated with the method after it's execution. In other programming languages, such as JavaScript, this responsibility falls on <span class = "rbcode">functions</span>. For example, if you had an array of names which you wanted to print out to the console, in JavaScript you might create a function similar to the following, followed by a specific call to the function:
      <pre class = "prettyprint lang-js linenums">
      function printNames (names) {
        for (var i = 0; i < names.length; i++) {
          console.log(names[i]);
        }
      }

      &gt;&gt; printNames(["Jerry", "George", "Elaine", "Kramer"]);
      &gt;&gt; Jerry
      &gt;&gt; George
      &gt;&gt; Elaine
      &gt;&gt; Kramer</pre>
    </p>
    <p>
      Ruby does not have it's own <span class = "rbcode">function</span> class, but <span class = "rbcode">Proc</span>s and <span class = "rbcode">lambda</span>s are often referred to as (anonymous) functions because they allow for self-contained code sequences to be created, stored, and used as arguments in methods, as well as executed following a <span class = "rbcode">call</span> request.
    </p>
    <p>
      Here we will be discussing Ruby's callable objects <span class = "rbcode">Proc</span> and <span class = "rbcode">lambda</span>. We'll begin, however, with a brief discussion of Ruby <span class = "rbcode">block</span>s. While not <em>technically</em> objects (one of the few things that is not an object in Ruby!), understanding blocks is required in order to get a handle on procs and lambdas.
    </p>
    <h4>Blocks</h4>
    <p>
      Even if you are relatively new to Ruby, you are probably by now familiar with blocks. A block is simply a sequence of code that can be executed. Block syntax uses either <span class = "rbcode">do...end</span> or <span class = "rbcode">{}</span>. The blocks you encounter will predominantly be used with iterators and enumerators, like so:
      <pre class = "prettyprint lang-rb linenums">
      [1,2,3,4].each do |n|
        puts n
      end
      &gt;&gt; 1
      &gt;&gt; 2
      &gt;&gt; 3
      &gt;&gt; 4

      %w{sort words by length}.sort_by { |word| word.length }
      &gt;&gt; ["by", "sort", "words", "length"] </pre>
    </p>
    <p>
    Here, the <span class = "rbcode">each</span> method accepts the block <span class = "rbcode">{ puts n }</span>, telling <span class = "rbcode">each</span> to iterate over the array of numbers and execute the code <span class = "rbcode">puts n</span>, which prints each number, followed by a new line, to the console. Likewise, the <span class = "rbcode">sort_by</span> method accepts the block <span class = "rbcode">{ |word| word.length }</span>, instructing the method to iterate over the array of strings and organize them in ascending order according to the length of each word.
    </p>
    <p>
    What you may not know, especially if you are new to Ruby, is that blocks can also be supplied as arguments to the methods you create. Blocks supplied as method parameters are distinguished by a preceding "&" symbol. Methods that accept blocks as parameters are followed by calls to the block inside the method, like so:
    <pre class = "prettyprint lang-rb linenums">
    def call_a_block(&block)
      block.call
    end
    call_a_block { puts "I'm a block!" }
    &gt;&gt; "I'm a block!"</pre>
    </p>
    <p>
    In this case, the method <span class = "rbcode">call_a_block</span> receives a block as a parameter, and when it sees <span class = "rbcode">block.call</span> in its method definition, executes the code in the supplied block. In reality, what is happening here is that the method <span class = "rbcode">call_a_block</span> is taking the supplied block and transforming it into a <span class = "rbcode">Proc</span> object, to be subsequently used within the method. It is important to note that labeling the block <span class = "rbcode">&block</span> is arbitrary. Any name can be preceded by the "&" symbol and become a proc. However, the <span class = "rbcode">block.call</span> code would necessarily need to be altered as well.
    </p>
    <p>
    At the moment this might seem confusing, but it should become clear once we understand what a <span class = "rbcode">Proc</span> is, and how it differs from a <span class = "rbcode">block</span>.
    </p>
    <h4>Procs</h4>
    <p>
    For starters, you may think of a block as a proc. However, a block is a proc that cannot be saved and stored away for later use. In the <span class = "rbcode">each</span> and <span class = "rbcode">sort_by</span> examples above, once the block is executed, that's it; in order to use it again you'd have to retype the entire code, method and all (or copy and paste it). Not so with procs. You can save procs for reuse anytime they are needed. Let's see how they work.
    </p>
    <p>
      To create a new <span class = "rbcode">Proc</span> object, use the <span class = "rbcode">new</span> method, followed by a code block:
    <pre class = "prettyprint lang-rb linenums">
      Proc.new { #some code to execute } # do..end also work here.</pre>
    </p>
    <p>
    To execute the same code as the JavaScript function above, you could then do the following:
    <pre class = "prettyprint lang-rb linenums">
    print_names = Proc.new { |name| puts name }
    names = ["Jerry", "George", "Elaine", "Kramer"]
    print_names.call(names)
    &gt;&gt; Jerry
    &gt;&gt; George
    &gt;&gt; Elaine
    &gt;&gt; Kramer </pre>
    </p>
    <p>
    The proc <span class = "rbcode">print_names</span> is called on the array <span class = "rbcode">names</span>, at which point the proc calls the block <span class = "rbcode">{|name| puts name}</span> on each element in the array.
    </p>
    <p>
    In the above example, we have saved a proc in a variable named <span class = "rbcode">print_names</span>, and executed it's contents using the <span class = "rbcode">call</span> method. However, procs can also be used as method arguments. For example, printing out the names in the <span class = "rbcode">names</span> array could just as easily been executed using Ruby's built-in <span class = "rbcode">each</span> method, followed by a block similar to that of the proc <span class = "rbcode">print_names</span>:
    <pre class = "prettyprint lang-rb linenums">
    names.each { |name| puts name }
    &gt;&gt; Jerry
    &gt;&gt; George
    &gt;&gt; Elaine
    &gt;&gt; Kramer </pre>
    Nevertheless, the same code could be executed by saving the code block in a proc and calling it as an argument to the <span class = "rbcode">each</span> method:
    <pre class = "prettyprint lang-rb linenums">
    names.each(&print_names)
    &gt;&gt; Jerry
    &gt;&gt; George
    &gt;&gt; Elaine
    &gt;&gt; Kramer </pre>
    where the & symbol informs the <span class = "rbcode">each</span> method to expect a proc as an argument, in this case the proc object <span class = "rbcode">print_names</span>. (Remember, when I said that calling a block on a method turns it into a proc?)
    </p>
    <p>
    Perhaps you have some operations you'd like to pass on to the elements of an array. Procs can handle that as well:
    <pre class = "prettyprint lang-rb linenums">
    add_five = Proc.new { |n| n + 5 }
    [1,2,3,4,5].map(&add_five)
    &gt;&gt; [6,7,8,9,10] </pre>
    </p>
    <p>
    The beauty of <span class = "rbcode">Proc</span> objects is that they are portable; once defined, they are code blocks that can be used over and over again, in different instances and with different methods. To illustrate, if there were another array of names that we wanted to iterate over in order to print out the names individually, there would be no need to repeat the code block <span class = "rbcode">{ |name| puts name }</span>. We could again simply reuse the proc <span class = "rbcode">print_names</span> as an argument to the each method (or even more simply using the proc's <span class = "rbcode">call</span> method). In fact, <em>anytime</em> we desired the functionality of iterating over a series of elements so as to print each to the console, we could use the proc we created. (However, we may wish to rename the proc to be more general yet descriptive in its purpose). The next two examples illustrate this idea:
    <pre class = "prettyprint lang-rb linenums">
    new_names = ["Leonard", "Penny", "Sheldon", "Amy", "Howard", "Bernadette", "Raj"]
    print_names.call(new_names) # equivalent to new_names.each(&print_names)
    &gt;&gt; Leonard
    &gt;&gt; Penny
    &gt;&gt; Sheldon
    &gt;&gt; Amy
    &gt;&gt; Howard
    &gt;&gt; Bernadette
    &gt;&gt; Raj

    numbers = [1,2,3,4,5]
    numbers.each(&print_names) # an example of why the proc should be named more generally
    &gt;&gt; 1
    &gt;&gt; 2
    &gt;&gt; 3
    &gt;&gt; 4
    &gt;&gt; 5 </pre>
    </p>
    <p>
    Finally, one of the most useful uses of procs is to utilize Ruby's built-in <span class = "rbcode">Symbol#to_proc</span> technique to cut down on block writing. The idea is that Ruby accepts "symbolized" versions of built-in methods and interprets them as messages to be sent to each element of an array or hash. To illustrate,
    <pre class = "prettyprint lang-rb linenums">
    %w{ sort words by length }.sort_by(&:length)
    &gt;&gt; ["by", "sort", "words", "length"]

    %w{ ruby is an awesome programming language }.map(&:capitalize)
    &gt;&gt; ["Ruby", "Is", "An", "Awesome", "Programming", "Language"]</pre>
    In the above code, we've used Ruby's <span class = "rbcode">Proc</span> and <span class = "rbcode">Symbol#to_proc</span> built-ins to simplify sorting by length and capitalizing each element of an array. The code <span class = "rbcode">&:length</span> and <span class = "rbcode">&:capitalize</span> is short-hand for <span class = "rbcode">{ |word| word.length }</span> and <span class = "rbcode">{ |word| word.capitalize }</span>, respectively. The power of this technique to significantly cut down on code writing time is immediately obvious.
    </p>
    <p>
    As you experiment with procs you'll quickly realize how powerful they can be. If you need to repeat a code block or multiple code blocks in your program, it's probably best to save them as a proc, or even a lambda, to which we turn to next.
    </p>
    <h4>Lambdas</h4>
    <p>
      Lambdas are most similar to anonymous functions in other languages, and are nearly identical to Procs. Like <span class = "rbcode">Proc.new</span>, the <span class = "rbcode">lambda</span> method returns a proc object with the supplied code block acting as the body of the function:
      <pre class = "prettyprint lang-rb linenums">
      my_lambda = lambda { #code goes here }</pre>
    </p>
    <p>
    Lambdas have three important differences with procs. First, lambdas require explicit declaration. In other words, lambdas must be created using either the <span class = "rbcode">lambda { ... }</span> syntax above, or, since Ruby 1.9.x, the shortened syntax <span class = "rbcode">-> ( ){ ... }</span>. This means that calls such as <span class = "rbcode">&block</span> will always result in regular proc objects, not lambdas. To briefly illustrate the shortened syntax,
    <pre class = "prettyprint lang-rb linenums">
    times_two = -> (x) { x * 2 }
    &gt;&gt; times_two.call(15)
    &gt;&gt; 30

    # is equivalent to:

    times_two = lambda { |x| x * 2 }
    &gt;&gt; times_two.call(15)
    &gt;&gt; 30</pre>
    </p>
    <p>
    Second, lambdas differ from procs in how they handle the <span class = "rbcode">return</span> keyword. When a lambda encounters a <span class = "rbcode">return</span> call within its code block, it exits its block and enters the immediately surrounding code context. Conversely, when a proc encounters a <span class = "rbcode">return</span>, the proc returns out of not only it's block but also out of the surrounding environment (e.g. a method containing the proc). Take the following example:
    <pre class = "prettyprint lang-rb linenums">
    def testing_return
      puts "setting lambda..."
      lam = lambda { return }
      puts "...calling lambda..."
      lam.call
      puts "...lambda called, back inside the method..."
      puts "...setting Proc.."
      proc = Proc.new { return }
      puts "...calling Proc..."
      proc.call
      puts "...are you still there?!"
    end

    &gt;&gt; testing_return
    &gt;&gt; setting lambda...
    &gt;&gt; ...calling lambda...
    &gt;&gt; ...lambda called, back inside the method...
    &gt;&gt; ...setting Proc..
    &gt;&gt; ...calling Proc...</pre>
    As you can see, when <span class = "rbcode">return</span> is called within the lambda, it returns to the inside of method body that called it. However, when the proc calls <span class = "rbcode">return</span>, the result is a complete exit from the method. Thus, the string "...are you still there?!" will never be output to the console.
    </p>
    <p>
    Finally, lambdas differ from procs in that lambdas will return an <span class = "rbcode">ArgumentError</span> if called with the incorrect number of arguments, whereas procs will evaluate what it can. As an example,
    <pre class = "prettyprint lang-rb linenums">
    times_twol = -> (x) { x * 2 }
    times_twop = Proc.new { |x| x * 2 }

    &gt;&gt; times_twol.call(2,3)
    &gt;&gt; #=> wrong number of arguments (2 for 1)

    &gt;&gt; times_twop.call(2,3)
    &gt;&gt; 4 </pre>
    As you can see, calling the lambda <span class = "rbcode">times_twol</span> with the wrong number of arguments led to an error. However, doing the same with the proc <span class = "rbcode">times_twop</span> led to the first argument being evaluated and returned to the console. The extra argument was ignored and did not lead to an error.
    </p>
    <h3>Conclusion</h3>
    <p>
    To summarize what we've learned, Ruby has a number of so-called "callable" objects that act as the equivalent to functions in other languages. <span class = "rbcode">block</span>s in ruby are single-use snippets of code to be executed when called. <span class = "rbcode">block</span>s are similar to Ruby's <span class = "rbcode">Proc</span> objects, except that the latter is capable of being saved for repeated use, in addition to being used as method parameters. Finally, there is the subset of the <span class = "rbcode">Proc</span> object, <span class = "rbcode">lambda</span>, which is nearly identical to <span class = "rbcode">Proc</span> except that it is particular when it comes to handing arguments and <span class = "rbcode">return</span> statements, and must be explicitly defined.
    </p>
    <p>
    Hopefully by now Ruby's callable objects are clear, as are their uses. I encourage you to experiment with each of them yourself, in order to develop a deeper understanding of how they work in various contexts. Happy coding.
    </p>
  </section>
  <section>
    <div id="nav-footer">
      <p class="post-nav"><a href="./c5-feedback.html">Previous</a> |</p>
      <p class="post-nav"><a href="./index.html">Home</a> |</p>
      <p class="post-nav"><a href="./c6-stereotype-threat.html">Next</a></p>
    </div>
  </section>
</main>
</div>
</div>
</body>
</html>