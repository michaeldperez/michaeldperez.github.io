<!DOCTYPE html>
<html>
<head>
  <title>Ruby Arrays vs. Hashes</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/default.css">
  <link type="text/css" rel="stylesheet" href="../stylesheets/blog-stylesheet.css" />
  <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js">
  </script>
</head>
<body>
<div class = "overlay">
<div class="blog-post-background">
<main>
  <h1>Ruby Container Objects:</h1>
  <h2>Comparing Arrays and Hashes</h2>
  <h4>7 January 2015</h4>

  <section>
    <h3></h3>
    <p>
      Much of programming is dealing with collections of objects. For example, you may search through a customer database to pull information on specific order types, or you may sort individual customers by location. In Ruby, these objects are typically stored inside two types of <em>container</em> objects: <em>arrays</em>, and <em>hashes</em>. Here, I'll briefly describe both the <span class="rbcode">Array</span> and the <span class="rbcode">Hash</span> classes. I'll begin by introducing each class individually before concluding with a brief discussion on how they compare with one another. Since this is only a brief introduction to Ruby's container objects, those interested in a more thorough treatment are referred to "Chapter 9: Collection and Container Objects" in David A. Black's <a href="http://www.manning.com/black3/">The Well-Grounded Rubyist</a>, and "Chapter 3: Ruby's Building Blocks: Data, Expressions, and Flow Control" in Peter Cooper's <a href="http://www.apress.com/9781430223634/">Beginning Ruby</a>.
    </p>
    <h4>Arrays</h4>
    <p>
      An <em>array</em> is an ordered collection of objects. Objects within an array are indexed by integers. If <span class ="rbcode">n</span> is the length, or the total number of objects in the array, then objects in the array are indexed beginning with 0, and continue incrementally until the final object in the collection, which is indexed by <span clas="rbcode">n &ndash; 1</span>. Any object can be stored in an array: strings, numbers, booleans, symbols, even other arrays and hashes.
    </p>
    <p>
      Arrays can be created one of four ways:
      <ul>
        <li>By making a call to the <span class = "rbcode">new</span> method.</li>
        <li>Literally, using the square bracket array constructor ([]).</li>
        <li>With the <span class = "rbcode">Array</span> method.</li>
        <li>With the special <span class = "rbcode">%w{...}</span> notation.</li>
      </ul>
      Here I'll only be using the literal notation because it is the most common among the various array constructors. Readers interested in learning the other methods for creating arrays are referred to Ruby's online documentation <a href="http://www.ruby-doc.org/core-2.0/Array.html">site</a> and/or the references cited above.
    </p>
    <p>
      Using the literal constructor, an empty array can be created as follows:
      <pre class = "prettyprint lang-rb linenums">
      &gt;&gt; x = []
      &gt;&gt; #=> []
      </pre>
      Literal constructors can also accommodate objects placed within the array at the time of creation. For example:
      <pre class = "prettyprint lang-rb linenums">
      &gt;&gt; x = [1,2,'hello','world']
      &gt;&gt: #=> [1,2,'hello','world']
      </pre>
      creates an array, assigned to the variable <span class = "rbcode">x</span>, which contains four elements: the numbers 1 and 2; as well as two strings: "hello" and "world". Note that assigning the array to the variable <span class = "rbcode">x</span> is arbitrary. One could just as easily have assigned the array to the variable <span class = "rbcode">a</span>, or the variable <span class = "rbcode">spaghetti</span>; It doesn't matter, although in your own code it <em>is</em> a good idea to label your variables in a way that is expressive.
    </p>
    <p>
      As mentioned above, array objects are indexed by integers. Therefore, to access an element in an array, all one needs to do is reference the object by it's index in the array. For example, if we wanted to access the element "hello" in array <span class = "rbcode">x</span> above, all we would need to do is call the array and reference the "hello" element's index, which in this case is 2 (remember that indexing begins at 0 and since "hello" is the third element in the array it's index is 2):
      <pre class = "prettyprint lang-rb linenums">
      &gt;&gt; x[2]
      &gt;&gt; #=> "Hello"
      </pre>
      As we can see, referencing the second index in the array <span class = "rbcode">x</span> results in "hello" being printed to the terminal (as signified by the "#=>" character).
    </p>
    <p>
      Notably, array elements can be assigned to specific indicies&mdash;or reassigned if an element already exists&mdash;in a similar fashion. If we want to add the element "foo" to the array <span class = "rbcode">x</span> as it's fifth element, we can do so by simply typing:
      <pre class = "prettyprint lang-rb linenums">
      &gt;&gt; x[4] = 'foo'
      &gt;&gt; x
      &gt;&gt; #=> [1, 2, 'hello', 'world', 'foo']
      </pre>
      Likewise, if we wanted to change the fifth element from "foo" to "bar", we would apply the same code again, this time assigning the fourth index to "bar" instead of "foo":
      <pre class = "prettyprint lang-rb linenums">
      &gt;&gt; x
      &gt;&gt; #=> [1, 2, 'hello', 'world', 'foo']
      &gt;&gt; x[4] = 'bar'
      &gt;&gt; x
      &gt;&gt; #=> [1, 2, ,'hello', 'world', 'bar']
      </pre>
      There are other ways to add elements to existing arrays, so readers should consult the Ruby documentation and ensure that they are familiar with these techniques.
    </p>
    <h4>Hashes</h4>
    <p>
      A hash, like an array, is a collection of indexed objects. Objects in a hash are stored in pairs, corresponding to a <em>key</em> and a <em>value</em>. Whereas arrays are indexed by integers, a hash's indicies&mdash;it's keys&mdash;can be objects of any type: strings, integers, symbols, etc. However, hash keys must be unique; for any given key there can be only one key/value pair.
    </p>
    <p>
      There are three ways to create a hash:
      <ul>
        <li>With the curly braces literal constructor ({}).</li>
        <li>With a call to the <span class = "rbcode">new</span> method.</li>
        <li>With the square brackets method ([]).</li>
      </ul>
      Once more, I'll primarily focus on the literal constructor, although I will demonstrate a call to the <span class = "rbcode">new</span> method when we discuss setting a hash's default value. If you are curious about the <span class = "rbcode">Hash</span> class's square brackets method, please consult the Ruby documentation.
    </p>
    <p>
      To create a hash using the literal constructor, you simply type:
      <pre class = "prettyprint lang-rb linenums">
      &gt;&gt; y = {}
      &gt;&gt; #=> {}
      </pre>
      Here an empty hash is assigned to the arbitrarily named variable "y". If you want to add values to the hash at the time of creation, you separate keys from their values with the "=>" operator, like so:
      <pre class = "prettyprint lang-rb linenums">
      &gt;&gt; spaghetti = {
        "sauce" => "tomato",
        "pasta" => "angel hair",
        "meat"  => "italian sausage"
      }
      &gt;&gt; #=> {"sauce" => "tomato", "pasta" => "angel hair", "meat" => "italian sausage"}
      </pre>
      The values in the hash "spaghetti", "tomato", "angel hair", and "meat", are indexed by their respective keys: "sauce", "pasta", and "meat". I have decided to use strings as my keys, but remember that any valid Ruby object will suffice. One common way to index hash values is through <a href = "http://ruby-doc.org/core-2.2.0/Symbol.html">symbols</a>. If you use symbols as keys, then you can use the special <span class = "rbcode">{ key: value }</span> syntax instead of the standard <span class = "rbcode">{ key => value }</span> syntax:
      <pre class = "prettyprint lang-rb linenums">
       &gt;&gt; spaghetti = {
        sauce: "tomato",
        pasta: "angel hair",
        meat:  "italian sausage"
      }
      &gt;&gt; #=> {:sauce => "tomato", :pasta => "angel hair", :meat => "italian sausage"}
      </pre>
      The choice is yours whether to use symbols as keys or some other Ruby object. However, there are a number of benefits to using symbols (see this discussion on <a href ="http://stackoverflow.com/questions/8189416/why-use-symbols-as-hash-keys-in-ruby">StackOverflow</a>). As such, I'll switch to using symbols as keys in the examples that follow.
    </p>
    <p>
      The technique for adding a key/value pair to a hash is the same as adding an element to an array:
      <pre class = "prettyprint lang-rb linenums">
      &gt;&gt; spaghetti[:spice] = "basil"
      &gt;&gt; #=> "basil"
      &gt;&gt; spaghetti
      &gt;&gt; #=> {:sauce => "tomato", :pasta => "angel hair", :meat => "italian sausage", :spice => "basil"}
      </pre>
      As you can see, the <span class = "rbcode">{ :spice => "basil" }</span> key/pair has been added to the <span class = "rbcode">spaghetti</span> hash.
    </p>
    <p>
      Always keep in mind that hash keys must be unique. While you can assign the same <em>value</em> to two or more keys, duplicating keys results in the replacement of the original key. For example, let's say we wanted to add to our hash another <span class = "rbcode">:spice</span> key, this time with the value of "oregano":
      <pre class = "prettyprint lang-rb linenums">
      &gt;&gt; spaghetti[:spice] = "oregano"
      &gt;&gt; #=> "oregano"
      &gt;&gt; spaghetti
      &gt;&gt; #=> {:sauce => "tomato", :pasta => "angel hair", :meat => "italian sausage", :spice => "oregano"}
      </pre>
      As expected, the "basil" value has been replaced in the hash by "oregano."
    </p>
    <p>
      Retrieving hash values is also done in the same way as retrieving array values: one simply calls a hash's value by making reference to it's key:
      <pre class = "prettyprint lang-rb linenums">
      &gt;&gt; spaghetti[:pasta]
      &gt;&gt; #=> "angel hair"
      </pre>
    </p>
    <p>
      You can also assign default values to hashes. Like arrays, when you try to access or reference a hash value by a key that does not exist, you get <span class = "rbcode">nil</span>:
      <pre class = "prettyprint lang-rb linenums">
      &gt;&gt; spaghetti[:servings]
      &gt;&gt; #=> nil
      </pre>
      Using the <span class = "rbcode">Hash.new</span> method however, you can supply an argument to the method and assign a different default value. So let's pretend that we were able to go back to the time of the <span class = "rbcode">spaghetti</span> hash's creation, this time specifying a default value:
      <pre class = "prettyprint lang-rb linenums">
      &gt;&gt; spaghetti = Hash.new(0)
      &gt;&gt; #=> {}
      </pre>
      Then, assuming we subsequently added the previous keys, when we attempt to access a nonexistent key the terminal will now return the specified default value:
      <pre class = "prettyprint lang-rb linenums">
      &gt;&gt; spaghetti[:sauce]
      &gt;&gt; #=> "tomato"
      &gt;&gt; spaghetti[:servings]
      &gt;&gt; #=> 0
      </pre>
      If we wanted to change this specific value, we could do so by reassigning the <span class = "rbcode">servings</span> key to a new value.
    </p>
    <h4>So How Do Arrays Compare to Hashes?</h4>
    <p>
      Both arrays and hashes are ordered collections. In the case of arrays, items are indexed numerically by consecutive integers. Items in a hash, however, are not numerically indexed but the order in which key/value pairs were entered is remembered. Values in arrays can be any valid Ruby object, but indicies must be consecutive integers and you have no control over them. Both keys (indicies) and values in hashes can be any type of Ruby object. However, keys must be unique. Thus, you have greater control over indicies and values with a hash. Nevertheless, it is useful to think of hashes as a type of array, and arrays as a type of hash: hashes can be thought of as arrays whose indicies need not be consecutive integers and arrays can be thought of as hashes whose keys just happen to be numerically ordered.
    </p>
    <p>
      There is much more to Ruby's container objects than what was briefly discussed here. Ruby's arrays and hashes are capability-rich and powerful objects. Part of what makes these objects so useful is their ability to quickly and efficiently store, combine, transform, and query information. As you continue on your journey to learn Ruby you'll necessarily make more use of these two classes. This blog has served as only an introduction to Ruby container objects. Hopefully it has adequately prepared you to continue learning about hashes and arrays, as well as provided the resources to do so.
    </p>
    <p>
      Curious where to go from here? In addition to the two chapters referenced in the beginning of this post, interested readers should consult Dan Nguyen's <em>The Bastard's Book of Ruby</em>'s chapter on <a href = "http://ruby.bastardsbook.com/chapters/collections/">collections</a>. Enjoy.
    </p>
  </section>
  <section>
    <div id="nav-footer">
      <p class="post-nav"><a href="./t2-css-design.html">Previous</a> |</p>
      <p class="post-nav"><a href="./index.html">Home</a> |</p>
      <p class="post-nav"><a href="./c3-thinking-style.html">Next</a></p>
    </div>
  </section>
</main>
</div>
</div>
</body>
</html>